<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script id="vertex-shader-2d" type="notjs">

        // 一个属性变量，将会从缓冲中获取数据
        attribute vec2 a_position;


        uniform mat3 u_matrix;
        varying vec4 v_color;
        // 所有着色器都有一个main方法
        void main() {

            // gl_Position 是一个顶点着色器主要设置的变量
            gl_Position = vec4((u_matrix * vec3(a_position, 1)).xy, 0, 1);
            
            v_color = gl_Position * 0.5 + 0.5;
        }
        
    </script>

    <script id="fragment-shader-2d" type="notjs">
        // 片段着色器没有默认精度，所以我们需要设置一个精度
        // mediump是一个不错的默认值，代表“medium precision”（中等精度）
        precision mediump float;
        
        //全局变量接收自定义颜色
        varying vec4 v_color;

        void main() {
        // gl_FragColor是一个片段着色器主要设置的变量
        gl_FragColor = v_color; // 返回“瑞迪施紫色”
        }
        
    </script>
    <script src="https://webglfundamentals.org/webgl/resources/webgl-lessons-ui.js"></script>
    <script src="https://webglfundamentals.org/webgl/resources/m3.js"></script>

</head>
</head>

<body>
    <canvas id="canvas" width="600" height="400"></canvas>
    <script>
        //根据输入的shader源码、shader类型创建shader
        function compileShader(gl, shaderSource, shaderType) {
            //创建着色器
            var shader = gl.createShader(shaderType);
            //设置着色器源码
            gl.shaderSource(shader, shaderSource);

            //编译着色器
            gl.compileShader(shader);
 

            // 检测编译是否成功
            var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
            if (!success) {
                // 编译过程出错，获取错误信息。
                throw "could not compile shader:" + gl.getShaderInfoLog(shader);
            }

            return shader;
        }

        //根据两个着色器 进行创建一个program
        function createProgram(gl, vertexShader, fragmentShader) {
            var program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            // 检查链接是否成功
            var success = gl.getProgramParameter(program, gl.LINK_STATUS);
            if (!success) {
                // 链接过程出现问题
                throw ("program failed to link:" + gl.getProgramInfoLog(program));
            }

            return program;
        }

        //通过script的类型提供给compileShader进行创建shader
        function createShaderFromScript(gl, scriptId, opt_shaderType) {
            var shaderScript = document.getElementById(scriptId);
            if (!shaderScript) {
                throw ("*** Error: unknown script element" + scriptId);
            }

            // 提取标签内容。
            var shaderSource = shaderScript.text;

            if (!opt_shaderType) {
                if (shaderSource.type == "x-shader/x-vertex") {
                    opt_shaderType = gl.VERTEX_SHADER;
                } else if (shaderSource.type == "x-shader/x-fragment") {
                    opt_shaderType = gl.FRAGMENT_SHADER;
                } else {
                    throw ("*** Error: shader type not set");
                }
            }
            return compileShader(gl, shaderSource, opt_shaderType);
        }

        //通过提供给这个函数id，进行一次性创建两个shader
        function createProgramFromScripts(gl, vertexShaderId, fragmentShaderId) {
            var vertexShader = createShaderFromScript(gl, vertexShaderId, gl.VERTEX_SHADER);
            var fragmentShader = createShaderFromScript(gl, fragmentShaderId, gl.FRAGMENT_SHADER);
            return createProgram(gl, vertexShader, fragmentShader);
        }

        var canvas = document.querySelector('#canvas');
        var gl = canvas.getContext('webgl');
        if (!gl) {
            alert('你不能使用WebGL！');
        }

        var program = createProgramFromScripts(gl, "vertex-shader-2d", "fragment-shader-2d");

        // look up where the vertex data needs to go.
        var positionAttributeLocation = gl.getAttribLocation(program, "a_position");
        //全局变量:分辨率

        //获取matrix
        var matrixLocation=gl.getUniformLocation(program,"u_matrix");

    
        //属性值从缓冲中获取数据，所以我们创建一个缓冲
        var positionBuffer = gl.createBuffer();

        gl.bindBuffer(gl.ARRAY_BUFFER,positionBuffer);

        // 定义一个三角形填充到缓冲里
        function setGeometry(gl) {
            gl.bufferData(
                gl.ARRAY_BUFFER,
                new Float32Array([
                    0, -100,
                    150, 125,
                    -175, 100]),
                gl.STATIC_DRAW);
        }
        setGeometry(gl);
        var translation = [200, 150];
        var angleInRadians = 0;
        var scale = [1, 1];
        //视口变换
        gl.viewport(0,0,gl.canvas.width,gl.canvas.height);

        //清空画布
        gl.clearColor(0,0,0,0);
        gl.clear(gl.COLOR_BUFFER_BIT);

        //告诉webgl使用写好的program
        gl.useProgram(program);

        
        //接下来我们需要告诉WebGL怎么从我们之前准备的缓冲中获取数据给着色器中的属性。 
        //首先我们需要启用对应属性
        gl.enableVertexAttribArray(positionAttributeLocation);
        // 告诉属性怎么从positionBuffer中读取数据 (ARRAY_BUFFER)
        var size = 2;          // 每次迭代运行提取两个单位数据
        var type = gl.FLOAT;   // 每个单位的数据类型是32位浮点型
        var normalize = false; // 不需要归一化数据
        var stride = 0;        // 0 = 移动单位数量 * 每个单位占用内存（sizeof(type)）
        // 每次迭代运行运动多少内存到下一个数据开始点
        var offset = 0;        // 从缓冲起始位置开始读取
        gl.vertexAttribPointer(
            positionAttributeLocation, size, type, normalize, stride, offset)


        // Compute the matrix
        var matrix = m3.projection(gl.canvas.clientWidth, gl.canvas.clientHeight);
        matrix = m3.translate(matrix, translation[0], translation[1]);
        matrix = m3.rotate(matrix, angleInRadians);
        matrix = m3.scale(matrix, scale[0], scale[1]);
        
        // Set the matrix.
        gl.uniformMatrix3fv(matrixLocation, false, matrix);

        // 绘制几何体
        var primitiveType = gl.TRIANGLES;
        var offset = 0;
        var count = 3;
        gl.drawArrays(primitiveType, offset, count);    


    </script>
</body>

</html>