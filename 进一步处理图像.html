<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script id="vertex-shader-2d" type="x-shader/x-vertex">
        attribute vec2 a_position;
        attribute vec2 a_texCoord;

        uniform vec2 u_resolution;
        uniform float u_flipY;

        varying vec2 v_texCoord;
        

        void main() {
            // convert the rectangle from pixels to 0.0 to 1.0
            vec2 zeroToOne = a_position / u_resolution;

            // convert from 0->1 to 0->2
            vec2 zeroToTwo = zeroToOne * 2.0;

            // convert from 0->2 to -1->+1 (clipspace)
            vec2 clipSpace = zeroToTwo - 1.0;

            gl_Position = vec4(clipSpace * vec2(1, u_flipY), 0, 1);

            // pass the texCoord to the fragment shader
            // The GPU will interpolate this value between points.
            v_texCoord = a_texCoord;
        }
    </script>
    <!-- fragment shader -->
    <script id="fragment-shader-2d" type="x-shader/x-fragment">
        precision mediump float;

        // our texture
        uniform sampler2D u_image;
        uniform vec2 u_textureSize;
        uniform float u_kernel[9];
        uniform float u_kernelWeight;

        // the texCoords passed in from the vertex shader.
        varying vec2 v_texCoord;


        void main() {
            //gl_FragColor = texture2D(u_image, v_texCoord).bgra;
            // 计算1像素对应的纹理坐标
            vec2 onePixel = vec2(1.0, 1.0) / u_textureSize;
            // 对左中右像素求均值
            gl_FragColor = (
                texture2D(u_image, v_texCoord) +
                texture2D(u_image, v_texCoord + vec2(onePixel.x, 0.0)) +
                texture2D(u_image, v_texCoord + vec2(-onePixel.x, 0.0))) / 3.0;
        }
    </script>
    <style>
        @import url("https://webglfundamentals.org/webgl/resources/webgl-tutorials.css");

        body {
            margin: 0;
        }

        #ui {
            font-size: x-small;
        }

        table {
            border-collapse: collapse;
            pointer-events: auto;
        }

        .tDnD_whileDrag {
            background-color: #daf !important;
        }

        tr:nth-child(odd) {
            background-color: #eee;
        }

        tr:nth-child(even) {
            background-color: #def;
        }

        td {
            border-width: 0px;
            padding: 0px;
            margin: 0px;
        }
    </style>
    </script>
    <script src="https://webglfundamentals.org/webgl/resources/jquery-1.7.1.min.js"></script>
    <script src="https://webglfundamentals.org/webgl/resources/jquery.tablednd_0_5.js"></script>
</head>

<body>
    <canvas id="canvas"></canvas>
    <div id="uiContainer">
        <div id="ui"></div>
    </div>
    <script>
        function compileShader(gl, shaderSource, shaderType) {
            var shader = gl.createShader(shaderType);
            gl.shaderSource(shader, shaderSource);
            gl.compileShader(shader);
            // 检测编译是否成功
            var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
            if (!success) {
                // 编译过程出错，获取错误信息。
                throw "could not compile shader:" + gl.getShaderInfoLog(shader);
            }

            return shader;
        }

        function createShaderFromScript(gl, scriptId, opt_shaderType) {
            var shaderScript = document.getElementById(scriptId);
            if (!shaderScript) {
                throw ("*** Error: unknown script element" + scriptId);
            }
            var shaderSource = shaderScript.text;

            if (!opt_shaderType) {
                if (!opt_shaderType) {
                    if (shaderScript.type == "x-shader/x-vertex") {
                        opt_shaderType = gl.VERTEX_SHADER;
                    } else if (shaderScript.type == "x-shader/x-fragment") {
                        opt_shaderType = gl.FRAGMENT_SHADER;
                    } else {
                        throw ("*** Error: shader type not set");
                    }
                }
            }
            return compileShader(gl, shaderSource, opt_shaderType);
        }

        function createProgram(gl, vertexShader, fragmentShader) {
            var program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            // 检查链接是否成功
            var success = gl.getProgramParameter(program, gl.LINK_STATUS);
            if (!success) {
                // 链接过程出现问题
                throw ("program failed to link:" + gl.getProgramInfoLog(program));
            }
            return program;
        }

        function createProgramFromScripts(gl, vertexShaderId, fragmentShaderId) {
            var vertexShader = createShaderFromScript(gl, vertexShaderId, gl.VERTEX_SHADER);
            var fragmentShader = createShaderFromScript(gl, fragmentShaderId, gl.FRAGMENT_SHADER);
            return createProgram(gl, vertexShader, fragmentShader);
        }

        function viewport(gl, width, height, program) {
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
            gl.clearColor(0, 0, 0, 0);
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.useProgram(program);
        }

        var canvas = document.querySelector('#canvas');
        var gl = canvas.getContext('webgl');

        if (!gl) {
            alert('你不能使用WebGL！');
        }
        var program = createProgramFromScripts(gl, "vertex-shader-2d", "fragment-shader-2d");

        var image = new Image();
        image.src = "./picture.jpg";


        var positionLocation = gl.getAttribLocation(program, "a_position");
        //获取纹理全局变量的地址
        var texCoordLocation = gl.getAttribLocation(program, 'a_texCoord');

        var positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        setRectangle(gl, 0, 0, image.width, image.height);

        //给矩阵提供纹理坐标
        var texCoordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            0.0, 0.0,
            1.0, 0.0,
            0.0, 1.0,
            0.0, 1.0,
            1.0, 0.0,
            1.0, 1.0
        ]), gl.STATIC_DRAW);


        //获取全局变量分辨率的地址
        var resolutionLocation = gl.getUniformLocation(program, 'u_resolution');

        //创建纹理
        function createAndSetupTexture(gl) {
            var texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);

            //设置材质，这样可以对任意大小的图像进行像素操作
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            return texture;
        }

        //创建纹理并写入图像, (将图像上传到纹理)
        var originalImageTexture = createAndSetupTexture(gl);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);

        //创建两个纹理绑定到帧缓冲
        var textures = [];
        var framebuffers = [];
        for (var ii = 0; ii < 2; ++ii) {
            var texture = createAndSetupTexture(gl);
            textures.push(texture);

            //设置纹理大小和图像大小一致
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, image.widht, image.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

            // 创建一个帧缓冲
            var fbo = gl.createFramebuffer();
            framebuffers.push(fbo);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo)

            // 绑定纹理到帧缓冲
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
        }

        // lookup uniforms
        var resolutionLocation = gl.getUniformLocation(program, "u_resolution");
        var textureSizeLocation = gl.getUniformLocation(program, "u_textureSize");
        var kernelLocation = gl.getUniformLocation(program, "u_kernel[0]");
        var kernelWeightLocation = gl.getUniformLocation(program, "u_kernelWeight");
        var flipYLocation = gl.getUniformLocation(program, "u_flipY");


        // 定义一些卷积核
        var kernels = {
            normal: [
                0, 0, 0,
                0, 1, 0,
                0, 0, 0
            ],
            gaussianBlur: [
                0.045, 0.122, 0.045,
                0.122, 0.332, 0.122,
                0.045, 0.122, 0.045
            ],
            unsharpen: [
                -1, -1, -1,
                -1, 9, -1,
                -1, -1, -1
            ],
            emboss: [
                -2, -1, 0,
                -1, 1, 1,
                0, 1, 2
            ]
        };

        // 将要使用的效果列表
        var effectsToApply = [
            "gaussianBlur",
            "emboss",
            "gaussianBlur",
            "unsharpen"
        ];

        // Setup a ui.
        var ui = document.querySelector("#ui");
        var table = document.createElement("table");
        var tbody = document.createElement("tbody");
        for (var ii = 0; ii < effectsToApply.length; ++ii) {
            var effect = effectsToApply[ii];
            var tr = document.createElement("tr");
            var td = document.createElement("td");
            var chk = document.createElement("input");
            chk.value = effect;
            chk.type = "checkbox";
            if (effect.on) {
                chk.checked = "true";
            }
            chk.onchange = drawEffects;
            td.appendChild(chk);
            td.appendChild(document.createTextNode('≡ ' + effect));
            tr.appendChild(td);
            tbody.appendChild(tr);
        }
        table.appendChild(tbody);
        ui.appendChild(table);
        $(table).tableDnD({ onDrop: drawEffects });




        // 从原始图像开始
        gl.bindTexture(gl.TEXTURE_2D, originalImageTexture);

        // 在渲染效果时不翻转y轴
        gl.uniform1f(flipYLocation, 1);


        drawEffects();
        function drawEffects(name) {
            // Clear the canvas
            gl.clearColor(0, 0, 0, 0);
            gl.clear(gl.COLOR_BUFFER_BIT);

            // Tell it to use our program (pair of shaders)
            gl.useProgram(program);

            // Turn on the position attribute
            gl.enableVertexAttribArray(positionLocation);

            // Bind the position buffer.
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

            // Tell the position attribute how to get data out of positionBuffer (ARRAY_BUFFER)
            var size = 2;          // 2 components per iteration
            var type = gl.FLOAT;   // the data is 32bit floats
            var normalize = false; // don't normalize the data
            var stride = 0;        // 0 = move forward size * sizeof(type) each iteration to get the next position
            var offset = 0;        // start at the beginning of the buffer
            gl.vertexAttribPointer(
                positionLocation, size, type, normalize, stride, offset);

            // Turn on the texcoord attribute
            gl.enableVertexAttribArray(texCoordLocation);

            // bind the texcoord buffer.
            gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);

            // Tell the texcoord attribute how to get data out of texcoordBuffer (ARRAY_BUFFER)
            var size = 2;          // 2 components per iteration
            var type = gl.FLOAT;   // the data is 32bit floats
            var normalize = false; // don't normalize the data
            var stride = 0;        // 0 = move forward size * sizeof(type) each iteration to get the next position
            var offset = 0;        // start at the beginning of the buffer
            gl.vertexAttribPointer(
                texCoordLocation, size, type, normalize, stride, offset);

            // set the size of the image
            gl.uniform2f(textureSizeLocation, image.width, image.height);

            // start with the original image
            gl.bindTexture(gl.TEXTURE_2D, originalImageTexture);

            // don't y flip images while drawing to the textures
            gl.uniform1f(flipYLocation, 1);

            // loop through each effect we want to apply.
            var count = 0;
            for (var ii = 0; ii < tbody.rows.length; ++ii) {
                var checkbox = tbody.rows[ii].firstChild.firstChild;
                if (checkbox.checked) {
                    // Setup to draw into one of the framebuffers.
                    setFramebuffer(framebuffers[count % 2], image.width, image.height);

                    drawWithKernel(checkbox.value);

                    // for the next draw, use the texture we just rendered to.
                    gl.bindTexture(gl.TEXTURE_2D, textures[count % 2]);

                    // increment count so we use the other texture next time.
                    ++count;
                }
            }

            // finally draw the result to the canvas.
            gl.uniform1f(flipYLocation, -1);  // need to y flip for canvas
            setFramebuffer(null, gl.canvas.width, gl.canvas.height);
            drawWithKernel("gaussianBlur");
        }

        function setFramebuffer(fbo, width, height) {
            // 设定当前使用的帧缓冲
            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);

            //告诉着色器分辨率
            gl.uniform2f(resolutionLocation, width, height);

            //告诉webgl帧缓冲需要的视图大小
            gl.viewport(0, 0, width, height);
        }

        function computeKernelWeight(kernel) {
            var weight = kernel.reduce((prev, curr) => {
                return prev + curr;
            });
            return weight <= 0 ? 1 : weight;
        }

        function drawWithKernel(name) {
            //设置卷积核
            gl.uniform1fv(kernelLocation, kernels[name]);
            gl.uniform1f(kernelWeightLocation, computeKernelWeight(kernels[name]));

            //画出矩形
            gl.drawArrays(gl.TRIANGLES, 0, 6);
        }




        function setRectangle(gl, x, y, width, height) {
            var x1 = x;
            var x2 = x + width;
            var y1 = y;
            var y2 = y + height;
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                x1, y1,
                x2, y1,
                x1, y2,
                x1, y2,
                x2, y1,
                x2, y2,
            ]), gl.STATIC_DRAW);
        }


    </script>
</body>

</html>