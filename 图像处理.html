<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script id="vertex-shader-2d" type="x-shader/x-vertex">
        attribute vec2 a_position;
        attribute vec2 a_texCoord;

        uniform vec2 u_resolution;

        varying vec2 v_texCoord;

        void main() {
            // convert the rectangle from pixels to 0.0 to 1.0
            vec2 zeroToOne = a_position / u_resolution;

            // convert from 0->1 to 0->2
            vec2 zeroToTwo = zeroToOne * 2.0;

            // convert from 0->2 to -1->+1 (clipspace)
            vec2 clipSpace = zeroToTwo - 1.0;

            gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);

            // pass the texCoord to the fragment shader
            // The GPU will interpolate this value between points.
            v_texCoord = a_texCoord;
        }
    </script>
    <!-- fragment shader -->
    <script id="fragment-shader-2d" type="x-shader/x-fragment">
        precision mediump float;

        // our texture
        uniform sampler2D u_image;

        uniform vec2 u_textureSize;

        // the texCoords passed in from the vertex shader.
        varying vec2 v_texCoord;

        void main() {
            //gl_FragColor = texture2D(u_image, v_texCoord).bgra;
            // 计算1像素对应的纹理坐标
            vec2 onePixel = vec2(1.0, 1.0) / u_textureSize;
            // 对左中右像素求均值
            gl_FragColor = (
                texture2D(u_image, v_texCoord) +
                texture2D(u_image, v_texCoord + vec2(onePixel.x, 0.0)) +
                texture2D(u_image, v_texCoord + vec2(-onePixel.x, 0.0))) / 3.0;
        }
    </script>
</head>

<body>
    <canvas id="canvas"></canvas>
    <script>
        function compileShader(gl,shaderSource,shaderType) {
            var shader=gl.createShader(shaderType);
            gl.shaderSource(shader,shaderSource);
            gl.compileShader(shader);
            // 检测编译是否成功
            var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
            if (!success) {
                // 编译过程出错，获取错误信息。
                throw "could not compile shader:" + gl.getShaderInfoLog(shader);
            }

            return shader;
        }
    
        function createShaderFromScript(gl,scriptId,opt_shaderType) {
            var shaderScript=document.getElementById(scriptId);
            if (!shaderScript) {
                throw ("*** Error: unknown script element" + scriptId);
            }
            var shaderSource=shaderScript.text;
            
            if(!opt_shaderType) {
                if (!opt_shaderType) {
                    if (shaderScript.type == "x-shader/x-vertex") {
                        opt_shaderType = gl.VERTEX_SHADER;
                    } else if (shaderScript.type == "x-shader/x-fragment") {
                        opt_shaderType = gl.FRAGMENT_SHADER;
                    } else {
                        throw ("*** Error: shader type not set");
                    }
                }
            }
            return compileShader(gl,shaderSource,opt_shaderType);
        }

        function createProgram (gl,vertexShader,fragmentShader) {
            var program=gl.createProgram();
            gl.attachShader(program,vertexShader);
            gl.attachShader(program,fragmentShader);
            gl.linkProgram(program);
            // 检查链接是否成功
            var success = gl.getProgramParameter(program, gl.LINK_STATUS);
            if (!success) {
                // 链接过程出现问题
                throw ("program failed to link:" + gl.getProgramInfoLog(program));
            }
            return program;
        }

        function createProgramFromScripts(gl,vertexShaderId,fragmentShaderId) {
            var vertexShader=createShaderFromScript(gl, vertexShaderId, gl.VERTEX_SHADER);
            var fragmentShader=createShaderFromScript(gl,fragmentShaderId,gl.FRAGMENT_SHADER);
            return createProgram(gl,vertexShader,fragmentShader);
        }
        

        function viewport(gl,width,height,program) {
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
            gl.clearColor(0,0,0,0);
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.useProgram(program);
        }

        var canvas=document.querySelector('#canvas');
        var gl=canvas.getContext('webgl');

        if (!gl) {
            alert('你不能使用WebGL！');
        }
        var program =createProgramFromScripts(gl, "vertex-shader-2d", "fragment-shader-2d");
        
        function main() {
            var img=new Image();
            img.src="./picture.jpg";
            img.onload=()=>{
                render(img);
            }
        }
        function render(image) {
            //获取纹理全局变量的地址
            var positionLocation =gl.getAttribLocation(program,"a_position");
            var texCoordLocation = gl.getAttribLocation(program,'a_texCoord');
            var textureSizeLocation = gl.getUniformLocation(program, "u_textureSize");

            var positionBuffer=gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER,positionBuffer);
            setRectangle(gl,0,0,image.width,image.height);

            //给矩阵提供纹理坐标
            var texCoordBuffer=gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER,texCoordBuffer);
            gl.bufferData(gl.ARRAY_BUFFER,new Float32Array([
                0.0, 0.0,
                1.0, 0.0,
                0.0, 1.0,
                0.0, 1.0,
                1.0, 0.0,
                1.0, 1.0
            ]),gl.STATIC_DRAW);
           
            
            //创建纹理
            var texture=gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D,texture);

            //设置参数，让我们可以绘制任何尺寸的图像；
            //包裹模式 (Wrap Mode) - 处理纹理坐标超出 [0, 1] 的情况
            /* 
                gl.TEXTURE_WRAP_S: 定义当纹理坐标的 U 分量（水平方向）超出 [0.0, 1.0] 范围时的行为。
                gl.TEXTURE_WRAP_T: 定义当纹理坐标的 V 分量（垂直方向）超出 [0.0, 1.0] 范围时的行为。
                gl.CLAMP_TO_EDGE: 这是您选择的模式。它表示当纹理坐标超出范围时，永远返回边缘像素的颜色。
            */
            gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);
            /* 
                过滤模式 (Filter Mode) - 处理纹理缩放时的采样方式
                gl.TEXTURE_MAG_FILTER: 当放大纹理时（纹理像素小于屏幕像素）使用的过滤器。
                gl.TEXTURE_MIN_FILTER: 当缩小纹理时（纹理像素大于屏幕像素）使用的过滤器。
                gl.NEAREST: 最近邻过滤。它会选择距离纹理坐标中心最近的那个纹素的颜色。
             */
            gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.NEAREST);

            //将图像上传到纹理
            gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,image);
        
            var resolutionLocation=gl.getUniformLocation(program,"u_resolution");

            viewport(gl,gl.canvas.width,gl.canvas.height,program);

            gl.enableVertexAttribArray(positionLocation);
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            var size=2;
            var type=gl.FLOAT;
            var normalize=false;
            var stride=0;
            var offset=0;
            gl.vertexAttribPointer(positionLocation,size,type,normalize,stride,offset);

            gl.enableVertexAttribArray(texCoordLocation);
            gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
            // Tell the texcoord attribute how to get data out of texcoordBuffer (ARRAY_BUFFER)
            var size = 2;          // 2 components per iteration
            var type = gl.FLOAT;   // the data is 32bit floats
            var normalize = false; // don't normalize the data
            var stride = 0;        // 0 = move forward size * sizeof(type) each iteration to get the next position
            var offset = 0;        // start at the beginning of the buffer
            gl.vertexAttribPointer(
                texCoordLocation, size, type, normalize, stride, offset);

            gl.uniform2f(textureSizeLocation, image.width, image.height);
            gl.uniform2f(resolutionLocation,gl.canvas.width,gl.canvas.height);

            //绘制
            var primitiveType=gl.TRIANGLES;
            var offset=0;
            var count =6;
            gl.drawArrays(primitiveType,offset,count);
        }

        function setRectangle(gl, x, y, width, height) {
            var x1 = x;
            var x2 = x + width;
            var y1 = y;
            var y2 = y + height;
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                x1, y1,
                x2, y1,
                x1, y2,
                x1, y2,
                x2, y1,
                x2, y2,
            ]), gl.STATIC_DRAW);
        }

        main();
    </script>
</body>
</html>