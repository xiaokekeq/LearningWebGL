<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script id="vertexShader3d" type="x-shader/x-vertex">
        attribute vec4 a_position;
        attribute vec4 a_color;

        uniform mat4 u_matrix;

        varying vec4 v_color;

        void main() {
        // Multiply the position by the matrix.
        gl_Position = u_matrix * a_position;

        // Pass the color to the fragment shader.
        v_color = a_color;
        }
    </script>
    <script id="fragmentShader3d" type="x-shader/x-fragment">
        precision mediump float;

        // Passed in from the vertex shader.
        varying vec4 v_color;

        uniform vec4 u_colorMult;

        void main() {
        gl_FragColor = v_color * u_colorMult;
        }

    </script>

    <style>
        @import url("https://webglfundamentals.org/webgl/resources/webgl-tutorials.css");

        body {
            margin: 0;
        }

        canvas {
            width: 100vw;
            height: 100vh;
            display: block;
        }
    </style>

    <script src="https://webglfundamentals.org/webgl/resources/webgl-utils.js"></script>
    <script src="https://webglfundamentals.org/webgl/resources/m4.js"></script>
    <script src="https://webglfundamentals.org/webgl/resources/primitives.js"></script>
    <script src="https://webglfundamentals.org/webgl/resources/chroma.min.js"></script>
</head>

<body>
    <canvas id="canvas"></canvas>
    <script>
        function main() {
            var canvas = document.querySelector("#canvas");
            var gl = canvas.getContext("webgl");
            if (!gl) {
                return;
            }

            // creates buffers with position, normal, texcoord, and vertex color
            // data for primitives by calling gl.createBuffer, gl.bindBuffer,
            // and gl.bufferData
            const sphereBufferInfo = primitives.createSphereWithVertexColorsBufferInfo(gl, 10, 12, 6);
            const cubeBufferInfo = primitives.createCubeWithVertexColorsBufferInfo(gl, 20);
            const coneBufferInfo = primitives.createTruncatedConeWithVertexColorsBufferInfo(gl, 10, 0, 20, 12, 1, true, false);

            //第三组新增
            var shapes = [
                sphereBufferInfo,
                cubeBufferInfo,
                coneBufferInfo
            ]



            // setup GLSL program
            var programInfo = webglUtils.createProgramInfo(gl, ["vertexShader3d", "fragmentShader3d"]);

            function degToRad(d) {
                return d * Math.PI / 180;
            }

            //第三组新增
            function rand(min, max) {
                return Math.random() * (max - min) + min;
            }
            //第三组新增
            function emod(x, n) {
                return x >= 0 ? (x % n) : ((n - (-x % n)) % n);
            }

            var cameraAngleRadians = degToRad(0);
            var fieldOfViewRadians = degToRad(60);
            var cameraHeight = 50;

            /* // Uniforms for each object.
            var sphereUniforms = {
                u_colorMult: [0.5, 1, 0.5, 1],
                u_matrix: m4.identity()
            }

            var cubeUniforms = {
                u_colorMult: [1, 0.5, 0.5, 1],
                u_matrix: m4.identity()
            }

            var coneUniforms = {
                u_colorMult: [0.5, 0.5, 1, 1],
                u_matrix: m4.identity()
            }; */

            //物体都需要的设置光线
            /*  var uniformsThatAreTheSameForAllObjects = {
                 u_lightWorldPos: [-50, 30, 100],
                 u_viewInverse: m4.identity(),
                 u_lightColor: [1, 1, 1, 1],
             }
 
             var uniformsThatAreComputedForEachObject = {
                 u_worldViewProjection: m4.identity(),
                 u_world: m4.identity(),
                 u_worldInverseTranspose: m4.identity()
             } */

            //第三组新增
            var objectsToDraw = [];
            var objects = [];

            // Make infos for each object for each object.
            var baseHue = rand(0, 360);
            var numObjects = 200;
            for (var ii = 0; ii < numObjects; ii++) {
                var object = {
                    uniform: {
                        u_colorMult: chroma.hsv(emod(baseHue + rand(0, 120), 360), rand(0.5, 1), rand(0.5, 1)).gl(),
                        u_matrix: m4.identity(),
                    },
                    translation: [rand(-100, 100), rand(-100, 100), rand(-150, -50)],
                    xRotationSpeed: rand(0.8, 1.2),
                    yRotationSpeed: rand(0.8, 1.2),
                };
                objects.push(object);
                objectsToDraw.push({
                    programInfo: programInfo,
                    bufferInfo: shapes[ii % shapes.length],
                    uniforms: object.uniform,
                });
            }


            var sphereTranslation = [0, 0, 0];
            var cubeTranslation = [-40, 0, 0];
            var coneTranslation = [40, 0, 0];

            /* var objectsToDraw = [
                {
                    programInfo: programInfo,
                    bufferInfo: sphereBufferInfo,
                    uniforms: sphereUniforms
                },
                {
                    programInfo: programInfo,
                    bufferInfo: cubeBufferInfo,
                    uniforms: cubeUniforms
                },
                {
                    programInfo: programInfo,
                    bufferInfo: coneBufferInfo,
                    uniforms: coneUniforms
                }
            ] */


            function computeMatrix(viewProjectionMatrix, translation, xRotation, yRotation) {
                var matrix = m4.translate(viewProjectionMatrix,
                    translation[0],
                    translation[1],
                    translation[2]
                )
                matrix = m4.xRotate(matrix, xRotation);
                return m4.yRotate(matrix, yRotation);
            }


            requestAnimationFrame(drawScene);

            function drawScene(time) {
                time *= 0.0005;

                webglUtils.resizeCanvasToDisplaySize(gl.canvas);

                // Tell WebGL how to convert from clip space to pixels
                gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

                gl.enable(gl.CULL_FACE);
                gl.enable(gl.DEPTH_TEST);

                // Clear the canvas AND the depth buffer.
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

                // Compute the projection matrix
                var aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
                var projectionMatrix = m4.perspective(fieldOfViewRadians, aspect, 1, 2000);

                // Compute the camera's matrix using look at.
                var cameraPosition = [0, 0, 100];
                var target = [0, 0, 0];
                var up = [0, 1, 0];
                var cameraMatrix = m4.lookAt(cameraPosition, target, up);

                var viewMatrix = m4.inverse(cameraMatrix);

                var viewProjectionMatrix = m4.multiply(projectionMatrix, viewMatrix)

                var sphereXRotation = time;
                var sphereYRotation = -time;
                var cubeXRotation = -time;
                var cubeYRotation = time;
                var coneXRotation = time;
                var coneYRotation = -time;
                /* 
                    // ------ Draw the sphere --------
                    gl.useProgram(programInfo.program);

                    // Setup all the needed attributes.
                    webglUtils.setBuffersAndAttributes(gl, programInfo, sphereBufferInfo);

                    sphereUniforms.u_matrix = computeMatrix(
                        viewProjectionMatrix,
                        sphereTranslation,
                        sphereXRotation,
                        sphereYRotation
                    );

                    // Set the uniforms we just computed
                    webglUtils.setUniforms(programInfo, sphereUniforms);
                    gl.drawArrays(gl.TRIANGLES, 0, sphereBufferInfo.numElements);

                    // ------ Draw the cube --------

                    // Setup all the needed attributes.
                    webglUtils.setBuffersAndAttributes(gl, programInfo, cubeBufferInfo);

                    cubeUniforms.u_matrix = computeMatrix(
                        viewProjectionMatrix,
                        cubeTranslation,
                        cubeXRotation,
                        cubeYRotation
                    )

                    // Set the uniforms we just computed
                    webglUtils.setUniforms(programInfo, cubeUniforms);
                    gl.drawArrays(gl.TRIANGLES, 0, cubeBufferInfo.numElements);

                    // ------ Draw the cone --------

                    // Setup all the needed attributes.
                    webglUtils.setBuffersAndAttributes(gl, programInfo, coneBufferInfo);

                    coneUniforms.u_matrix = computeMatrix(
                        viewProjectionMatrix,
                        coneTranslation,
                        coneXRotation,
                        coneYRotation
                    )

                    // Set the uniforms we just computed
                    webglUtils.setUniforms(programInfo, coneUniforms);

                    gl.drawArrays(gl.TRIANGLES, 0, coneBufferInfo.numElements);

                    requestAnimationFrame(drawScene)
             */

                /*  // Compute the matrices for each object.
                 sphereUniforms.u_matrix = computeMatrix(
                     viewProjectionMatrix,
                     sphereTranslation,
                     sphereXRotation,
                     sphereYRotation
                 );
                 cubeUniforms.u_matrix = computeMatrix(
                     viewProjectionMatrix,
                     cubeTranslation,
                     cubeXRotation,
                     cubeYRotation
                 );
                 coneUniforms.u_matrix = computeMatrix(
                     viewProjectionMatrix,
                     coneTranslation,
                     coneXRotation,
                     coneYRotation
                 );
 
                 objectsToDraw.forEach(object => {
                     var programInfo = object.programInfo;
                     var bufferInfo = object.bufferInfo;
 
                     gl.useProgram(programInfo.program);
 
                     // Setup all the needed attributes.
                     webglUtils.setBuffersAndAttributes(gl, programInfo, bufferInfo);
 
                     // Set the uniforms.
                     webglUtils.setUniforms(programInfo, object.uniforms);
 
                     gl.drawArrays(gl.TRIANGLES, 0, bufferInfo.numElements);
 
                 })
                 requestAnimationFrame(drawScene); */

                // Compute the matrices for each object.
                objects.forEach(object => {
                    object.uniform.u_matrix = computeMatrix(
                        viewProjectionMatrix,
                        object.translation,
                        object.xRotationSpeed * time,
                        object.yRotationSpeed * time,
                    );
                });
                // ------ Draw the objects --------
                var lastUsedProgramInfo = null;
                var lastUsedBufferInfo = null;

                objectsToDraw.forEach(object => {
                    var programInfo = object.programInfo;
                    var bufferInfo = object.bufferInfo;
                    var bindBuffers = false;
                    if (programInfo != lastUsedProgramInfo) {
                        lastUsedProgramInfo = programInfo;
                        gl.useProgram(programInfo.program);

                        // We have to rebind buffers when changing programs because we
                        // only bind buffers the program uses. So if 2 programs use the same
                        // bufferInfo but the 1st one uses only positions the when the
                        // we switch to the 2nd one some of the attributes will not be on.
                        bindBuffers = true;
                    }

                    if (bindBuffers || bufferInfo !== lastUsedBufferInfo) {
                        lastUsedBufferInfo = bufferInfo;
                        webglUtils.setBuffersAndAttributes(gl, programInfo, bufferInfo);
                    }

                    // Set the uniforms.
                    webglUtils.setUniforms(programInfo,object.uniforms);
                    // Draw
                    gl.drawArrays(gl.TRIANGLES,0,bufferInfo.numElements);
                });
                requestAnimationFrame(drawScene);
            }
        }
        main();
    </script>
</body>

</html>