<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script id="vertexShader3d" type="x-shader/x-vertex">
        uniform mat4 u_worldViewProjection;
        uniform vec3 u_lightWorldPosition;
        uniform mat4 u_world;
        uniform mat4 u_viewInverse;
        uniform mat4 u_worldInverseTranspose;

        attribute vec4 a_position;
        attribute vec3 a_normal;
        attribute vec2 a_texcoord;

        varying vec4 v_position;
        varying vec2 v_texcoord;
        varying vec3 v_normal;
        varying vec3 v_surfaceToLight;
        varying vec3 v_surfaceToView;

        void main(){
            v_texcoord = a_texcoord;
            v_position = (u_worldViewProjection * a_position);
            v_normal = (u_worldInverseTranspose * vec4(a_normal, 0)).xyz;
            v_surfaceToLight = u_lightWorldPosition - (u_world * a_position).xyz;
            v_surfaceToView = (u_viewInverse[3] - (u_world * a_position)).xyz;
            gl_Position = v_position;
        }
    </script>

    <script id="fragmentShader3d" type="x-shader/x-fragment">
        precision mediump float;

        varying vec4 v_position;
        varying vec2 v_texcoord;
        varying vec3 v_normal;
        varying vec3 v_surfaceToLight;
        varying vec3 v_surfaceToView;

        uniform vec4 u_lightColor;
        uniform vec4 u_colorMult;
        uniform sampler2D u_diffuse;
        uniform vec4 u_specular;
        uniform float u_shininess;
        uniform float u_specularFactor;

        vec4 lit(float l, float h, float m){
            return vec4(1.0,
                abs(l),
                (l>0.0)?pow(max(0.0,h),m):0.0,
                1.0);
        }

        void main(){
            vec4 diffuseColor=texture2D(u_diffuse,v_texcoord);
            vec3 a_normal=normalize(v_normal);
            vec3 surfaceToLight=normalize(v_surfaceToLight);
            vec3 surfaceToView=normalize(v_surfaceToView);
            vec3 halfVector=normalize(surfaceToLight+surfaceToView);
            vec4 litR=lit(dot(a_normal,surfaceToLight),dot(a_normal,halfVector),u_shininess);
            vec4 outColor=vec4((
                u_lightColor*(diffuseColor*litR.y*u_colorMult+
                u_specular*litR.z*u_specularFactor)).rgb,diffuseColor.a);
            gl_FragColor=outColor;
        }

    </script>
    <style>
        @import url("https://webglfundamentals.org/webgl/resources/webgl-tutorials.css");

        body {
            margin: 0;
        }

        canvas {
            width: 100vw;
            height: 100vh;
            display: block;
        }
    </style>
    <script src="https://webglfundamentals.org/webgl/resources/webgl-utils.js"></script>
    <script src="https://webglfundamentals.org/webgl/resources/m4.js"></script>
    <script src="https://webglfundamentals.org/webgl/resources/primitives.js"></script>
    <script src="https://webglfundamentals.org/webgl/resources/texture-utils.js"></script>
    <script src="https://webglfundamentals.org/webgl/resources/chroma.min.js"></script>
</head>

<body>
    <canvas id="canvas"></canvas>
    <script>
        function main() {
            var canvas = document.querySelector("#canvas");
            var gl = canvas.getContext("webgl");
            if (!gl) {
                return;
            }

            // a single triangle
            var arrays = {
                position: { numComponents: 3, data: [0, -10, 0, 10, 10, 0, -10, 10, 0], },
                texcoord: { numComponents: 2, data: [0.5, 0, 1, 1, 0, 1], },
                normal: { numComponents: 3, data: [0, 0, 1, 0, 0, 1, 0, 0, 1] },
            }

            var bufferInfo = webglUtils.createBufferInfoFromArrays(gl, arrays);

            // setup GLSL program
            var program = webglUtils.createProgramFromScripts(gl, ["vertexShader3d", "fragmentShader3d"])
            var uniformSetters = webglUtils.createUniformSetters(gl, program);
            var attribSetters = webglUtils.createAttributeSetters(gl, program);

            function degToRad(d) {
                return d * Math.PI / 180;
            }

            var cameraAngleRadians = degToRad(0);
            var fieldOfViewRadians = degToRad(60);
            var cameraHeight = 50;

            var uniformsThatAreTheSameForAllObjects = {
                u_lightWorldPosition: [-50, 30, 100],
                u_viewInverse: m4.identity(),
                u_lightColor: [1, 1, 1, 1],
            }

            var uniformsThatAreComputedForEachObject = {
                u_worldViewProjection: m4.identity(),
                u_world: m4.identity(),
                u_worldInverseTranspose: m4.identity(),
            }

            var rand = (min, max) => {
                if (max === undefined) {
                    max = min;
                    min = 0;
                }
                return min + Math.random() * (max - min);
            }

            var randInt = range => Math.floor(Math.random() * range);

            var textures = [
                textureUtils.makeStripeTexture(gl, { color1: "#FFF", color2: "#CCC", }),
                textureUtils.makeCheckerTexture(gl, { color1: "#FFF", color2: "#CCC", }),
                textureUtils.makeCircleTexture(gl, { color1: "#FFF", color2: "#CCC", }),
            ]

            var objects = [];
            var numObjects = 300;
            var baseColor = rand(240);
            for (var ii = 0; ii < numObjects; ii++) {
                objects.push({
                    radius: rand(150),
                    xRotation: rand(Math.PI * 2),
                    yRotation: rand(Math.PI),
                    materialUniforms: {
                        u_colorMult: chroma.hsv(rand(baseColor, baseColor + 120), 0.5, 1).gl(),
                        u_diffuse: textures[randInt(textures.length)],
                        u_specular: [1, 1, 1, 1],
                        u_shininess: rand(500),
                        u_specularFactor: rand(1),
                    }
                })
            }

            requestAnimationFrame(drawScene);

            function drawScene(time) {
                time = time * 0.0001 + 5;
                webglUtils.resizeCanvasToDisplaySize(gl.canvas);

                // Tell WebGL how to convert from clip space to pixels
                gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

                gl.enable(gl.DEPTH_TEST);

                // Clear the canvas AND the depth buffer.
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

                // Compute the projection matrix
                var aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
                var projectionMatrix = m4.perspective(fieldOfViewRadians, aspect, 1, 2000);

                // Compute the camera's matrix using look at.
                var cameraPosition = [0, 0, 100];
                var target = [0, 0, 0];
                var up = [0, 1, 0];
                var cameraMatrix = m4.lookAt(cameraPosition, target, up, uniformsThatAreTheSameForAllObjects.u_viewInverse);

                // Make a view matrix from the camera matrix.
                var viewMatrix = m4.inverse(cameraMatrix);

                var viewProjectionMatrix = m4.multiply(projectionMatrix, viewMatrix);

                gl.useProgram(program);

                // Setup all the needed attributes.
                webglUtils.setBuffersAndAttributes(gl, attribSetters, bufferInfo);

                // Set the uniforms that are the same for all objects.
                webglUtils.setUniforms(uniformSetters, uniformsThatAreTheSameForAllObjects);

                //Draw Objects
                objects.forEach(object => {

                    // Compute a position for this object based on the time.
                    var worldMatrix = m4.xRotation(object.xRotation * time);
                    worldMatrix = m4.yRotate(worldMatrix, object.yRotation * time);
                    worldMatrix = m4.translate(worldMatrix, 0, 0, object.radius);

                    // Multiply the matrices.
                    m4.multiply(viewProjectionMatrix, worldMatrix, uniformsThatAreComputedForEachObject.u_worldViewProjection);
                    m4.transpose(m4.inverse(worldMatrix), uniformsThatAreComputedForEachObject.u_worldInverseTranspose);

                    // Set the uniforms we just computed
                    webglUtils.setUniforms(uniformSetters, uniformsThatAreComputedForEachObject);

                    // Set the uniforms that are specific to the this object.
                    webglUtils.setUniforms(uniformSetters,object.materialUniforms);

                    // Draw the geometry.
                    gl.drawArrays(gl.TRIANGLES,0,bufferInfo.numElements);
                });
                requestAnimationFrame(drawScene);
            }
        }

        main();
    </script>
</body>

</html>