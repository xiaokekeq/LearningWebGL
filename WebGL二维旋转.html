<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>

    <script src="https://webglfundamentals.org/webgl/resources/jquery-1.7.1.min.js"></script>
    <script src="https://webglfundamentals.org/webgl/resources/jquery-ui-1.8.16.custom.min.js"></script>
    <script src="https://webglfundamentals.org/webgl/resources/jquery.mousecapture.js"></script>
    <script src="https://webglfundamentals.org/webgl/resources/jquery.gman.ui.js"></script>
    <script src="https://webglfundamentals.org/webgl/resources/jquery-gman-circle.js"></script>
    <!--
    for most samples webgl-utils only provides shader compiling/linking and
    canvas resizing because why clutter the examples with code that's the same in every sample.
    See https://webglfundamentals.org/webgl/lessons/webgl-boilerplate.html
    and https://webglfundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html
    for webgl-utils, m3, m4, and webgl-lessons-ui.
    -->
    <script src="https://webglfundamentals.org/webgl/resources/webgl-utils.js"></script>
    <script src="https://webglfundamentals.org/webgl/resources/webgl-lessons-ui.js"></script>

    <script id="vertex-shader-2d" type="x-shader/x-vertex">
        attribute vec2 a_position;

        uniform vec2 u_resolution;
        uniform vec2 u_translation;
        uniform vec2 u_rotation;

        //u_rotation.x 和 u_rotation.y 分别代表 sinθ 和 cosθ（或反之，取决于传入的顺序）。
        void main() {
            //旋转位置
            vec2 rotatePosition = vec2(
                a_position.x * u_rotation.y + a_position.y * u_rotation.x,
                a_position.y * u_rotation.y - a_position.x * u_rotation.x);

            //加上平移
            vec2 position=rotatePosition+u_translation;

            vec2 zeroToOne=position/u_resolution;
            vec2 zeroToTwo=zeroToOne*2.0;

            vec2 clipSpace=zeroToTwo-1.0;

            gl_Position=vec4(clipSpace*vec2(1,-1),0,1);

        }
        </script>

    <script id="fragment-shader-2d" type="x-shader/x-fragment">
        precision mediump float;
        uniform vec4 u_color;
        void main() {
            gl_FragColor=u_color;
        }
    </script>
    <style>
        @import url("https://webglfundamentals.org/webgl/resources/css/ui-lightness/jquery-ui-1.8.16.custom.css");
        @import url("https://webglfundamentals.org/webgl/resources/webgl-tutorials.css");

        body {
            margin: 0;
        }

        canvas {
            width: 100vw;
            height: 100vh;
            display: block;
        }
    </style>
</head>

<body>
    <canvas id="canvas"></canvas>
    <div id="uiContainer">
        <div id="ui">
            <div id="x"></div>
            <div id="y"></div>
            <div id="rotation"></div>
        </div>
    </div>
    <script>
        function main() {
            var canvas = document.querySelector("#canvas");
            var gl = canvas.getContext("webgl");
            if (!gl) {
                return;
            }

            var program = webglUtils.createProgramFromScripts(gl, ["vertex-shader-2d", "fragment-shader-2d"]);

            var positionLocation = gl.getAttribLocation(program, 'a_position');

            //查找uniform地址
            var resolutionLocation = gl.getUniformLocation(program, 'u_resolution');
            var colorLocation = gl.getUniformLocation(program, 'u_color');
            var translationLocation = gl.getUniformLocation(program, 'u_translation');
            var rotationLocation = gl.getUniformLocation(program, 'u_rotation');

            //创建缓冲区
            var positionBuffer = gl.createBuffer();
            //ARRAY_BUFFER 绑定点绑定数据源
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            setGeometry(gl);

            var translation = [100, 150];
            var rotation = [0, 1];//0度
            var color = [Math.random(), Math.random(), Math.random(), 1];

            drawScene();

            //setup a ui
            webglLessonsUI.setupSlider("#x", { value: translation[0], slide: updatePosition(0), max: gl.canvas.width });
            webglLessonsUI.setupSlider("#y", { value: translation[1], slide: updatePosition(1), max: gl.canvas.height });
            webglLessonsUI.setupSlider("#rotation", { slide: updateAngle, max: 360 })
            // $("#rotation").gmanUnitCircle({
            //     width: 200,
            //     height: 200,
            //     value: 0,
            //     slide: function (e, u) {
            //         rotation[0] = u.x;
            //         rotation[1] = u.y;
            //         drawScene();
            //     }
            // });
            function updatePosition(index) {
                return function (event, ui) {
                    translation[index] = ui.value;
                    drawScene();
                }
            }

            function updateAngle(event,ui) {
                var angleInDegrees = 360 - ui.value;
                var angleInRadians = angleInDegrees * Math.PI / 180;
                rotation[0] = Math.sin(angleInRadians);
                rotation[1] = Math.cos(angleInRadians);
                drawScene();
            }

            function drawScene() {
                webglUtils.resizeCanvasToDisplaySize(gl.canvas);

                // Tell WebGL how to convert from clip space to pixels
                gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

                // Clear the canvas.
                gl.clear(gl.COLOR_BUFFER_BIT);

                /// Tell it to use our program (pair of shaders)
                gl.useProgram(program);

                // Turn on the attribute
                gl.enableVertexAttribArray(positionLocation);
                // Bind the position buffer.
                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

                // Tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)
                var size = 2;
                var type = gl.FLOAT;
                var normalize = false;
                var stride = 0;
                var offset = 0;
                gl.vertexAttribPointer(positionLocation, size, type, normalize, stride, offset);

                // set the resolution
                gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height);

                // set the color
                gl.uniform4fv(colorLocation, color);

                // set the translation
                gl.uniform2fv(translationLocation, translation);

                // set the rotation
                gl.uniform2fv(rotationLocation, rotation);
                // Draw the geometry.
                var primitiveType = gl.TRIANGLES;
                var offset = 0;
                var count = 18;
                gl.drawArrays(primitiveType, offset, count);
            }


        }

        function setGeometry(gl) {
            var positions = new Float32Array([
                // left column
                0, 0,
                30, 0,
                0, 150,
                0, 150,
                30, 0,
                30, 150,

                // top rung
                30, 0,
                100, 0,
                30, 30,
                30, 30,
                100, 0,
                100, 30,

                // middle rung
                30, 60,
                67, 60,
                30, 90,
                30, 90,
                67, 60,
                67, 90,
            ]);
            gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
        }
        $(function () {
            main();
        });
    </script>
</body>

</html>